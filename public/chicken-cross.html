<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Play Chicken Cross Game Online at Rainbet</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0,viewport-fit=cover">
<meta name="theme-color" content="#11152B">
<link rel="icon" href="https://cdn.rainbet.com/brand/favicons/64x64.png">

<!-- PixiJS 7.4 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.2/pixi.min.js"></script>
<!-- GSAP + PixiPlugin -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.7/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.7/PixiPlugin.min.js"></script>
<!-- Howler.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>

<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%;overflow:hidden;background:#11152B;color:#E8E5FF;
  font-family:Inter,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
  font-size:14px;-webkit-font-smoothing:antialiased}

.app{display:flex;flex-direction:column;height:100vh;height:100dvh}

/* Header */
.hdr{display:flex;align-items:center;justify-content:space-between;
  padding:0 16px;height:56px;min-height:56px;background:#191F3B;
  border-bottom:1px solid #262C50;z-index:100}
.hdr-left{display:flex;align-items:center;gap:10px}
.logo{display:flex;align-items:center;gap:8px;text-decoration:none;color:#E8E5FF;font-weight:700;font-size:17px}
.logo-icon{width:30px;height:30px;background:linear-gradient(135deg,#0077DB,#005aa8);
  border-radius:7px;display:flex;align-items:center;justify-content:center;font-weight:900;font-size:15px;color:#fff}
.hdr-right{display:flex;align-items:center;gap:10px}
.bal-box{display:flex;align-items:center;gap:5px;background:#0077DB;padding:7px 14px;
  border-radius:6px;border:1px solid #1F99FF;color:#fff;font-weight:600;font-size:13px;cursor:pointer;user-select:none}
.bal-box:hover{background:#0069c4}
.bal-cur{opacity:.8;font-size:11px}
.avatar{width:34px;height:34px;border-radius:50%;background:linear-gradient(135deg,#7DD934,#5BB520);
  display:flex;align-items:center;justify-content:center;font-weight:bold;color:#fff;font-size:13px}

/* Main frame */
.frame{flex:1;display:flex;overflow:hidden;padding:12px;gap:0}
.container{flex:1;display:flex;background:#1B213C;border-radius:12px;overflow:hidden;border:1px solid #262C50}

/* Sidebar */
.sidebar{width:272px;min-width:272px;background:#191F3B;padding:14px;
  display:flex;flex-direction:column;gap:14px;border-right:1px solid #262C50;overflow-y:auto}
.lbl{font-size:11px;font-weight:600;color:#8B8DB5;text-transform:uppercase;letter-spacing:.5px;margin-bottom:3px}

/* Bet input */
.bet-wrap{display:flex;align-items:center;background:#141931;border:1px solid #33395C;border-radius:8px;overflow:hidden;transition:border-color .15s}
.bet-wrap:focus-within{border-color:#0077DB}
.bet-cur{padding:0 10px;color:#5E679E;font-size:13px;font-weight:600}
.bet-inp{flex:1;background:0 0;border:0;color:#E8E5FF;font-size:13px;padding:9px 0;outline:0;font-family:inherit;min-width:0;-moz-appearance:textfield}
.bet-inp::-webkit-inner-spin-button,.bet-inp::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}
.bet-btns{display:flex;gap:2px;padding:4px}
.bet-adj{background:#262C50;border:1px solid #33395C;color:#E8E5FF;padding:5px 9px;border-radius:5px;
  font-size:11px;font-weight:600;cursor:pointer;transition:all .15s;font-family:inherit}
.bet-adj:hover{background:#2A2F52;border-color:#454D7D}

/* Action button */
.act-btn{width:100%;padding:13px;border-radius:8px;border:0;font-size:15px;font-weight:700;
  cursor:pointer;font-family:inherit;transition:all .15s;text-transform:uppercase;letter-spacing:.4px}
.act-btn.cross{background:linear-gradient(180deg,#0077DB,#005aa8);color:#fff;box-shadow:0 4px 12px rgba(0,119,219,.4)}
.act-btn.cross:hover{background:linear-gradient(180deg,#0085f2,#0066be)}
.act-btn.cashout{background:linear-gradient(180deg,#7DD934,#5BB520);color:#fff;box-shadow:0 4px 12px rgba(125,217,52,.4);animation:pulse 1.5s ease-in-out infinite}
.act-btn.cashout:hover{background:linear-gradient(180deg,#8ee63f,#68c525)}
.act-btn:disabled{background:#262C50!important;color:#5E679E!important;cursor:not-allowed;box-shadow:none!important;animation:none!important}
@keyframes pulse{0%,100%{box-shadow:0 4px 12px rgba(125,217,52,.4)}50%{box-shadow:0 4px 20px rgba(125,217,52,.6)}}

/* Payout */
.payout{background:#141931;border:1px solid #33395C;border-radius:8px;padding:9px 13px;display:flex;justify-content:space-between;align-items:center}
.pay-lbl{font-size:12px;color:#8B8DB5}
.pay-val{font-size:15px;font-weight:700;color:#8B8DB5}
.pay-mult{font-size:13px;font-weight:600;color:#0077DB}

/* Risk */
.risk-grid{display:grid;grid-template-columns:1fr 1fr;gap:5px}
.risk-btn{padding:7px 10px;background:#262C50;border:1px solid #33395C;border-radius:6px;
  color:#8B8DB5;font-size:12px;font-weight:600;cursor:pointer;transition:all .15s;text-align:center;font-family:inherit}
.risk-btn:hover{background:#2A2F52;border-color:#454D7D;color:#E8E5FF}
.risk-btn.on{background:#0077DB;border-color:#1F99FF;color:#fff}

/* Game area */
.game-area{flex:1;display:flex;flex-direction:column;position:relative;background:#11152B}
.game-bar{display:flex;align-items:center;justify-content:space-between;
  padding:6px 14px;background:#191F3B;border-bottom:1px solid #262C50;min-height:38px}
.game-title{font-size:12px;font-weight:600;color:#8B8DB5;display:flex;align-items:center;gap:6px}
.game-title .emoji{font-size:15px}
.mult-trail{display:flex;gap:5px;align-items:center;overflow-x:auto;padding:2px 0}
.mbadge{padding:3px 7px;border-radius:4px;font-size:10px;font-weight:700;white-space:nowrap;
  background:#262C50;color:#8B8DB5;border:1px solid #33395C;transition:all .2s}
.mbadge.cur{background:#0077DB;color:#fff;border-color:#1F99FF}
.mbadge.done{background:rgba(125,217,52,.15);color:#7DD934;border-color:rgba(125,217,52,.3)}

/* Canvas container */
.canvas-box{flex:1;position:relative;overflow:hidden}
.canvas-box canvas{display:block;width:100%!important;height:100%!important}

/* Lanes overlay (clickable zones) */
.lanes-overlay{position:absolute;inset:0;display:flex;flex-direction:column;justify-content:center;
  align-items:center;pointer-events:none;z-index:10}
.lane-row{display:flex;gap:4px;pointer-events:none;margin:2px 0}
.lane-tile{width:60px;height:42px;border-radius:8px;border:2px solid transparent;cursor:default;
  pointer-events:none;transition:all .2s;display:flex;align-items:center;justify-content:center;
  font-size:12px;font-weight:700;color:transparent;background:transparent;font-family:inherit}
.lane-tile.active{pointer-events:auto;cursor:pointer;border-color:rgba(0,119,219,.5);
  background:rgba(0,119,219,.08);color:rgba(0,119,219,.6);animation:tileGlow 2s ease-in-out infinite}
.lane-tile.active:hover{border-color:#0077DB;background:rgba(0,119,219,.15);color:#0077DB;transform:scale(1.06)}
.lane-tile.safe{border-color:rgba(125,217,52,.5);background:rgba(125,217,52,.12);color:#7DD934;pointer-events:none}
.lane-tile.fail{border-color:rgba(231,69,69,.5);background:rgba(231,69,69,.12);color:#E74545;pointer-events:none}
.lane-tile.revealed{border-color:rgba(91,97,140,.3);background:rgba(91,97,140,.05);color:#5E679E;pointer-events:none}
@keyframes tileGlow{0%,100%{border-color:rgba(0,119,219,.4)}50%{border-color:rgba(0,119,219,.7)}}

/* Result overlay */
.result{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:50;
  animation:fadeIn .3s ease-out;pointer-events:none;display:none}
.result.win{background:rgba(125,217,52,.08)}
.result.lose{background:rgba(231,69,69,.08)}
.result.show{display:flex}
.result-card{background:#1B213C;border:2px solid #33395C;border-radius:16px;padding:28px 48px;
  text-align:center;box-shadow:0 20px 60px rgba(0,0,0,.5);animation:pop .4s cubic-bezier(.175,.885,.32,1.275);
  pointer-events:auto;cursor:pointer}
.result.win .result-card{border-color:rgba(125,217,52,.4)}
.result.lose .result-card{border-color:rgba(231,69,69,.4)}
.res-emoji{font-size:48px;margin-bottom:10px}
.res-text{font-size:22px;font-weight:700;margin-bottom:6px}
.result.win .res-text{color:#7DD934}
.result.lose .res-text{color:#E74545}
.res-amount{font-size:18px;color:#E8E5FF;font-weight:600}
.res-mult{font-size:13px;color:#8B8DB5;margin-top:5px}
.res-dismiss{font-size:10px;color:#5E679E;margin-top:10px}
@keyframes fadeIn{from{opacity:0}to{opacity:1}}
@keyframes pop{0%{transform:scale(.5);opacity:0}100%{transform:scale(1);opacity:1}}

/* Footer */
.game-ft{display:flex;align-items:center;justify-content:space-between;
  padding:5px 14px;background:#191F3B;border-top:1px solid #262C50;min-height:34px}
.ft-info{font-size:10px;color:#5E679E}
.ft-info kbd{background:#262C50;border:1px solid #33395C;border-radius:3px;padding:1px 4px;font-size:9px;font-family:inherit}
.reset-btn{background:0 0;border:1px solid #33395C;color:#8B8DB5;padding:3px 9px;border-radius:5px;
  font-size:10px;cursor:pointer;font-family:inherit;transition:all .15s}
.reset-btn:hover{background:#262C50;color:#E8E5FF}

/* History */
.hist{margin-top:auto;padding-top:10px;border-top:1px solid #262C50}
.hist-title{font-size:11px;font-weight:600;color:#5E679E;margin-bottom:5px;text-transform:uppercase}
.hist-list{display:flex;flex-direction:column;gap:3px;max-height:120px;overflow-y:auto}
.hist-item{display:flex;justify-content:space-between;padding:4px 7px;border-radius:4px;font-size:11px;background:#141931}
.hist-item.win{color:#7DD934}
.hist-item.lose{color:#E74545}

/* Mobile balance */
#mob-bal{display:none;position:fixed;top:7px;right:7px;background:linear-gradient(135deg,#0077DB,#005aa8);
  padding:7px 13px;border-radius:18px;border:2px solid #1F99FF;color:#fff;font-weight:700;font-size:13px;z-index:100000;
  box-shadow:0 2px 10px rgba(0,0,0,.3)}

/* Responsive */
@media(max-width:900px){
  .frame{padding:0;flex-direction:column}
  .container{flex-direction:column;border-radius:0;border:0}
  .sidebar{width:100%;min-width:unset;flex-direction:row;flex-wrap:wrap;padding:8px;gap:6px;
    border-right:0;border-top:1px solid #262C50;order:2;max-height:200px;overflow-y:auto}
  .bet-grp{flex:1;min-width:140px}
  .act-grp{flex:1;min-width:110px}
  .risk-grp{flex:1;min-width:140px}
  .pay-grp{flex:1;min-width:140px}
  .hist{display:none}
  .game-area{order:1}
}
@media(max-width:600px){
  .hdr{height:48px;min-height:48px;padding:0 8px}
  #mob-bal{display:flex!important;align-items:center;gap:3px}
  .hdr-right{display:none}
  .sidebar{padding:6px;gap:4px;max-height:170px}
  .act-btn{padding:10px;font-size:13px}
}
@media(max-width:900px) and (orientation:landscape){
  .container{flex-direction:row}
  .sidebar{order:0;width:210px;min-width:210px;flex-direction:column;max-height:unset;
    border-top:0;border-right:1px solid #262C50}
  .game-area{order:1}
  .hist{display:block}
}

::-webkit-scrollbar{width:5px}
::-webkit-scrollbar-track{background:transparent}
::-webkit-scrollbar-thumb{background:#33395C;border-radius:3px}
::-webkit-scrollbar-thumb:hover{background:#454D7D}
</style>
</head>
<body>
<div id="mob-bal"><span class="bal-cur">$</span><span id="mob-bal-amt">1,247.83</span></div>

<div class="app">
  <div class="hdr">
    <div class="hdr-left">
      <a href="/" class="logo"><div class="logo-icon">R</div><span>Rainbet</span></a>
    </div>
    <div class="hdr-right">
      <div class="bal-box" id="hdr-bal" title="Click to reset balance">
        <span class="bal-cur">$</span><span id="bal-amt">1,247.83</span>
      </div>
      <div class="avatar">Z</div>
    </div>
  </div>

  <div class="frame">
    <div class="container">
      <div class="sidebar">
        <div class="bet-grp">
          <div class="lbl">Bet Amount</div>
          <div class="bet-wrap">
            <span class="bet-cur">$</span>
            <input type="number" class="bet-inp" id="bet-inp" value="10.00" min="0.01" step="0.01">
            <div class="bet-btns">
              <button class="bet-adj" id="btn-half">¬Ω</button>
              <button class="bet-adj" id="btn-2x">2√ó</button>
            </div>
          </div>
        </div>
        <div class="act-grp">
          <button class="act-btn cross" id="act-btn"><span id="act-text">Cross</span></button>
        </div>
        <div class="pay-grp">
          <div class="payout">
            <div><div class="pay-lbl">Payout</div><div class="pay-val" id="pay-val">$0.00</div></div>
            <div class="pay-mult" id="pay-mult">0.00√ó</div>
          </div>
        </div>
        <div class="risk-grp">
          <div class="lbl">Risk</div>
          <div class="risk-grid">
            <button class="risk-btn on" data-risk="easy">Easy</button>
            <button class="risk-btn" data-risk="medium">Medium</button>
            <button class="risk-btn" data-risk="hard">Hard</button>
            <button class="risk-btn" data-risk="expert">Expert</button>
          </div>
        </div>
        <div class="hist" id="hist-sec">
          <div class="hist-title">Recent Bets</div>
          <div class="hist-list" id="hist-list"></div>
        </div>
      </div>

      <div class="game-area" id="game-area">
        <div class="game-bar">
          <div class="game-title"><span class="emoji">üêî</span>Chicken Cross</div>
          <div class="mult-trail" id="mult-trail"></div>
        </div>
        <div class="canvas-box" id="canvas-box"></div>
        <div class="result" id="result-ov"></div>
        <div class="game-ft">
          <div class="ft-info"><kbd>1</kbd>-<kbd>5</kbd> pick lane ¬∑ <kbd>Space</kbd> cross/cashout ¬∑ <kbd>Esc</kbd> cashout</div>
          <button class="reset-btn" id="reset-btn" title="Reset balance">‚Üª Reset $</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
'use strict';

// ===== Register GSAP PixiPlugin =====
gsap.registerPlugin(PixiPlugin);
PixiPlugin.registerPIXI(PIXI);

// ===== CONSTANTS =====
const ASSET_BASE = 'chicken-cross_files/assets';
const IMG_PATH = ASSET_BASE + '/images';
const AUDIO_PATH = ASSET_BASE + '/audio';
const STORAGE_KEY = 'rainbet_chicken_balance';
const BG_COLOR = 0x11152B;

// ===== DIFFICULTY CONFIG (from Rainbet's actual code) =====
// Multiplier formula: 96 / (prod_{i=0}^{n-1} (25-df-i)/(25-i) * 100)
// df = difficultyFactor, n = round number (1-indexed)
function calcMultiplier(round, difficultyFactor) {
    let prob = 1;
    for (let i = 0; i < round; i++) {
        prob *= (25 - difficultyFactor - i) / (25 - i);
    }
    let mult = 96 / (prob * 100);
    return Math.round(mult * 100) / 100; // 2 decimal places
}

const DIFFICULTIES = {
    easy:   { factor: 1,  maxRounds: 24, label: 'Easy' },
    medium: { factor: 3,  maxRounds: 22, label: 'Medium' },
    hard:   { factor: 5,  maxRounds: 20, label: 'Hard' },
    expert: { factor: 10, maxRounds: 15, label: 'Expert' }
};

// Precompute multiplier tables
for (const [key, diff] of Object.entries(DIFFICULTIES)) {
    diff.multipliers = [];
    for (let r = 1; r <= diff.maxRounds; r++) {
        diff.multipliers.push(calcMultiplier(r, diff.factor));
    }
}

// ===== PROVABLY FAIR ENGINE (HMAC-SHA512, from Rainbet's code) =====
async function hmacSHA512(key, message) {
    const enc = new TextEncoder();
    const cryptoKey = await crypto.subtle.importKey(
        'raw', enc.encode(key), { name: 'HMAC', hash: 'SHA-512' }, false, ['sign']
    );
    const sig = await crypto.subtle.sign('HMAC', cryptoKey, enc.encode(message));
    return Array.from(new Uint8Array(sig)).map(b => b.toString(16).padStart(2, '0')).join('');
}

function generateSeed() {
    const arr = new Uint8Array(32);
    crypto.getRandomValues(arr);
    return Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
}

async function computeFairValue(serverSeed, clientSeed, nonce, round) {
    const hash = await hmacSHA512(serverSeed, `${clientSeed}:${nonce}:${round}`);
    // Take first 4 bytes (8 hex chars)
    const val = parseInt(hash.substring(0, 8), 16);
    return val / 0x100000000; // 0 to 1
}

async function determineOutcome(serverSeed, clientSeed, nonce, round, difficulty) {
    const fairValue = await computeFairValue(serverSeed, clientSeed, nonce, round);
    const diff = DIFFICULTIES[difficulty];
    const multiplier = diff.multipliers[round - 1];
    const winPercentage = 96 / multiplier;
    
    if (100 * fairValue >= winPercentage) {
        return { win: false, multiplier: 0, fairValue };
    }
    return { win: true, multiplier, fairValue };
}

// ===== BALANCE SYSTEM =====
let balance = parseFloat(localStorage.getItem(STORAGE_KEY)) || 1247.83;

function saveBalance() { localStorage.setItem(STORAGE_KEY, balance.toFixed(2)); }
function fmtMoney(v) { return v.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }); }
function updateBalanceUI() {
    document.getElementById('bal-amt').textContent = fmtMoney(balance);
    document.getElementById('mob-bal-amt').textContent = fmtMoney(balance);
}

// ===== GAME STATE =====
let state = 'idle'; // idle | playing | cashing_out | game_over
let currentRisk = 'easy';
let currentRound = 0;
let betAmount = 0;
let serverSeed = '';
let clientSeed = '';
let nonce = 0;
let roundResults = [];

// ===== DOM REFS =====
const betInput = document.getElementById('bet-inp');
const actBtn = document.getElementById('act-btn');
const actText = document.getElementById('act-text');
const payVal = document.getElementById('pay-val');
const payMult = document.getElementById('pay-mult');
const resultOv = document.getElementById('result-ov');
const multTrail = document.getElementById('mult-trail');
const histList = document.getElementById('hist-list');
const canvasBox = document.getElementById('canvas-box');

// ===== SOUNDS (Howler.js) =====
const sounds = {};
function loadSounds() {
    const sfx = {
        chirp1: 'chirp-1.mp3',
        chickenWin: 'chicken-win.mp3',
        chickenLose: 'chicken-lose.mp3',
        carHit1: 'car-hit-1.mp3',
        carHit2: 'car-hit-2.mp3',
        carStopping: 'car-stopping.mp3',
        grateOpening: 'grate-opening.mp3',
        barrierImpact0: 'barrier-impact-0.mp3',
        barrierImpact1: 'barrier-impact-1.mp3',
        barrierImpact2: 'barrier-impact-2.mp3',
        trafficCarLoud1: 'traffic-car-1-loud.mp3',
        trafficCarLoud2: 'traffic-car-2-loud.mp3',
        trafficCarLoud3: 'traffic-car-3-loud.mp3',
        trafficCarLoud4: 'traffic-car-4-loud.mp3',
        trafficTruckLoud1: 'traffic-truck-1-loud.mp3',
        trafficTruckLoud2: 'traffic-truck-2-loud.mp3',
        trafficPoliceLoud: 'traffic-police-2-loud.mp3',
    };
    for (const [key, file] of Object.entries(sfx)) {
        try {
            sounds[key] = new Howl({ src: [AUDIO_PATH + '/' + file], html5: true, volume: 0.5 });
        } catch(e) {}
    }
}
function playSound(key) { try { sounds[key] && sounds[key].play(); } catch(e) {} }

// ===== PIXI APPLICATION =====
let app, sceneRoot, sceneContent, chickenContainer, lanesContainer;
let chickenSprites = {};
let laneContainers = [];
let spritesheets = {};
let tileSprites = {};

async function initPixi() {
    app = new PIXI.Application({
        width: canvasBox.clientWidth,
        height: canvasBox.clientHeight,
        autoDensity: true,
        resolution: Math.min(window.devicePixelRatio || 1, 2),
        antialias: true,
        backgroundColor: BG_COLOR,
    });
    canvasBox.appendChild(app.view);
    app.view.style.touchAction = 'none';

    // Root containers
    sceneRoot = new PIXI.Container();
    sceneRoot.sortableChildren = true;
    app.stage.addChild(sceneRoot);

    sceneContent = new PIXI.Container();
    sceneContent.sortableChildren = true;
    sceneRoot.addChild(sceneContent);

    // Load spritesheets
    await loadSpritesheets();

    // Build scene
    buildScene();

    // Resize handler
    const ro = new ResizeObserver(() => {
        if (!app) return;
        const w = canvasBox.clientWidth;
        const h = canvasBox.clientHeight;
        app.renderer.resize(w, h);
        layoutScene();
    });
    ro.observe(canvasBox);
    layoutScene();
}

async function loadSpritesheets() {
    const sheets = [
        { key: 'chicken-body', file: 'chicken-body-content.json' },
        { key: 'chicken-faces', file: 'chicken-faces.json' },
        { key: 'background-1', file: 'chicken-background-content-1.json' },
        { key: 'background-2', file: 'chicken-background-content-2.json' },
        { key: 'cars', file: 'chicken-cross-cars.json' },
        { key: 'blocker', file: 'blocker.json' },
    ];

    for (const s of sheets) {
        try {
            const jsonUrl = IMG_PATH + '/' + s.file;
            const resp = await fetch(jsonUrl);
            const json = await resp.json();
            // Fix the image path to be relative
            const imgName = json.meta.image;
            const imgUrl = IMG_PATH + '/' + imgName;
            
            // Load the texture
            const texture = await PIXI.Assets.load(imgUrl);
            
            // Create spritesheet
            const sheet = new PIXI.Spritesheet(texture, json);
            await sheet.parse();
            spritesheets[s.key] = sheet;
        } catch(e) {
            console.warn('Failed to load spritesheet:', s.key, e);
        }
    }
}

function getTexture(sheetKey, frameName) {
    const sheet = spritesheets[sheetKey];
    if (!sheet) return PIXI.Texture.WHITE;
    return sheet.textures[frameName] || PIXI.Texture.WHITE;
}

// ===== BUILD THE SCENE =====
function buildScene() {
    lanesContainer = new PIXI.Container();
    lanesContainer.sortableChildren = true;
    lanesContainer.name = 'lanes';
    sceneContent.addChild(lanesContainer);

    // Build chicken character
    buildChicken();

    // Build initial lanes
    rebuildLanes();
}

function buildChicken() {
    chickenContainer = new PIXI.Container();
    chickenContainer.name = 'chicken';
    chickenContainer.zIndex = 10;
    chickenContainer.scale.set(0.12);
    
    // Body parts from spritesheet
    const parts = [
        { key: 'tail', frame: 'chicken-tail.png', x: -120, y: -50 },
        { key: 'body', frame: 'chicken-torso.png', x: 0, y: 0 },
        { key: 'wing', frame: 'chicken-wing.png', x: 20, y: 10 },
        { key: 'legL', frame: 'chicken-leg.png', x: -30, y: 80 },
        { key: 'legR', frame: 'chicken-leg.png', x: 30, y: 80 },
        { key: 'neck', frame: 'chicken-neck.png', x: 60, y: -60 },
        { key: 'head', frame: 'chicken-red-head.png', x: 70, y: -100 },
    ];

    for (const p of parts) {
        const tex = getTexture('chicken-body', p.frame);
        const sprite = new PIXI.Sprite(tex);
        sprite.anchor.set(0.5);
        sprite.x = p.x;
        sprite.y = p.y;
        sprite.name = p.key;
        chickenContainer.addChild(sprite);
        chickenSprites[p.key] = sprite;
    }

    // Face
    const faceTex = getTexture('chicken-faces', 'default.png');
    const face = new PIXI.Sprite(faceTex);
    face.anchor.set(0.5);
    face.x = 85;
    face.y = -120;
    face.scale.set(0.9);
    face.name = 'face';
    chickenContainer.addChild(face);
    chickenSprites.face = face;

    sceneContent.addChild(chickenContainer);

    // Start idle animation
    startIdleAnimation();
}

function setChickenFace(frameName) {
    const tex = getTexture('chicken-faces', frameName);
    if (chickenSprites.face && tex !== PIXI.Texture.WHITE) {
        chickenSprites.face.texture = tex;
    }
}

function startIdleAnimation() {
    // Gentle breathing/bobbing
    gsap.killTweensOf(chickenContainer);
    gsap.to(chickenContainer, {
        pixi: { y: chickenContainer.y - 3 },
        duration: 1.2,
        yoyo: true,
        repeat: -1,
        ease: 'sine.inOut'
    });
    // Wing flutter
    if (chickenSprites.wing) {
        gsap.killTweensOf(chickenSprites.wing);
        gsap.to(chickenSprites.wing, {
            pixi: { rotation: 5 },
            duration: 0.8,
            yoyo: true,
            repeat: -1,
            ease: 'sine.inOut'
        });
    }
}

// ===== LANES =====
function rebuildLanes() {
    lanesContainer.removeChildren();
    laneContainers = [];
    tileSprites = {};

    const diff = DIFFICULTIES[currentRisk];
    const numLanes = Math.min(diff.maxRounds, 10); // Show up to 10 lanes on screen

    for (let i = 0; i < numLanes; i++) {
        const lane = new PIXI.Container();
        lane.name = 'lane-' + i;
        lane.sortableChildren = true;

        // Road surface
        const road = new PIXI.Graphics();
        road.beginFill(0x1A1F3A);
        road.drawRoundedRect(0, 0, 160, 50, 6);
        road.endFill();
        lane.addChild(road);

        // Road line markings
        const line = new PIXI.Graphics();
        line.beginFill(0x2A3055, 0.5);
        line.drawRect(10, 23, 30, 4);
        line.drawRect(60, 23, 30, 4);
        line.drawRect(110, 23, 30, 4);
        line.endFill();
        lane.addChild(line);

        // Cover tile (clickable region visual)
        const cover = new PIXI.Graphics();
        cover.beginFill(0x262C50, 0);
        cover.drawRoundedRect(0, 0, 160, 50, 6);
        cover.endFill();
        cover.name = 'cover';
        lane.addChild(cover);

        // Multiplier text
        const multText = new PIXI.Text('', {
            fontFamily: 'Inter, sans-serif',
            fontSize: 11,
            fontWeight: '700',
            fill: '#5E679E',
            align: 'center'
        });
        multText.anchor.set(0.5);
        multText.x = 80;
        multText.y = 25;
        multText.name = 'mult-text';
        lane.addChild(multText);

        // Barrier (blocker between lanes)
        const barrierTex = getTexture('blocker', 'no-crack-barrier.png');
        if (barrierTex !== PIXI.Texture.WHITE) {
            const barrier = new PIXI.Sprite(barrierTex);
            barrier.anchor.set(0.5, 1);
            barrier.x = 80;
            barrier.y = 0;
            barrier.scale.set(0.15);
            barrier.name = 'barrier';
            barrier.zIndex = 2;
            lane.addChild(barrier);
        }

        lanesContainer.addChild(lane);
        laneContainers.push(lane);
    }

    updateLaneVisuals();
}

function updateLaneVisuals() {
    const diff = DIFFICULTIES[currentRisk];
    const numLanes = laneContainers.length;

    for (let i = 0; i < numLanes; i++) {
        const lane = laneContainers[i];
        const multText = lane.getChildByName('mult-text');
        const cover = lane.getChildByName('cover');

        if (i < diff.multipliers.length) {
            const mult = diff.multipliers[i];
            if (multText) {
                multText.text = (mult >= 1000 ? mult.toFixed(0) : mult.toFixed(2)) + '√ó';
                
                if (state === 'playing') {
                    if (i < currentRound) {
                        // Cleared
                        multText.style.fill = '#7DD934';
                        multText.alpha = 0.7;
                    } else if (i === currentRound) {
                        // Current
                        multText.style.fill = '#0077DB';
                        multText.alpha = 1;
                    } else {
                        multText.style.fill = '#5E679E';
                        multText.alpha = 0.5;
                    }
                } else {
                    multText.style.fill = '#5E679E';
                    multText.alpha = 0.6;
                }
            }
        }
    }
}

// ===== LAYOUT =====
function layoutScene() {
    if (!app || !sceneContent) return;
    const W = app.renderer.width / app.renderer.resolution;
    const H = app.renderer.height / app.renderer.resolution;

    const diff = DIFFICULTIES[currentRisk];
    const numLanes = laneContainers.length;
    const laneW = 160;
    const laneH = 50;
    const gap = 8;
    const totalH = numLanes * (laneH + gap);

    // Position lanes from bottom to top
    const startY = H / 2 + totalH / 2 - laneH;
    for (let i = 0; i < numLanes; i++) {
        const lane = laneContainers[i];
        lane.x = W / 2 - laneW / 2;
        lane.y = startY - i * (laneH + gap);
    }

    // Position chicken
    if (chickenContainer) {
        const chickenLaneIdx = Math.min(currentRound, numLanes - 1);
        const targetLane = laneContainers[chickenLaneIdx];
        if (targetLane) {
            chickenContainer.x = targetLane.x + laneW / 2;
            chickenContainer.y = targetLane.y + laneH / 2 - 20;
        }
    }

    // Camera follow - scroll if needed
    if (state === 'playing' && currentRound > 3) {
        const scrollAmt = (currentRound - 3) * (laneH + gap);
        gsap.to(sceneContent, { y: scrollAmt, duration: 0.3, ease: 'power2.out' });
    } else {
        sceneContent.y = 0;
    }
}

// ===== CHICKEN ANIMATIONS =====
function animateChickenJump(targetLane, onComplete) {
    if (!chickenContainer || !targetLane) { onComplete && onComplete(); return; }

    const targetX = targetLane.x + 80;
    const targetY = targetLane.y + 5;
    const jumpHeight = 40;
    const duration = 0.35;

    // Anticipation squash
    const tl = gsap.timeline();
    
    tl.to(chickenContainer.scale, { x: 0.14, y: 0.10, duration: 0.08, ease: 'power2.in' });
    
    // Jump up
    tl.to(chickenContainer, {
        pixi: { x: targetX, y: targetY - jumpHeight },
        duration: duration * 0.5,
        ease: 'power2.out'
    });
    tl.to(chickenContainer.scale, { x: 0.11, y: 0.13, duration: duration * 0.5, ease: 'power2.out' }, '<');
    
    // Fall down
    tl.to(chickenContainer, {
        pixi: { y: targetY },
        duration: duration * 0.5,
        ease: 'power2.in'
    });
    tl.to(chickenContainer.scale, { x: 0.12, y: 0.12, duration: duration * 0.3, ease: 'bounce.out' }, '>-0.1');

    // Landing squash
    tl.to(chickenContainer.scale, { x: 0.14, y: 0.10, duration: 0.06, ease: 'power2.in' });
    tl.to(chickenContainer.scale, { x: 0.12, y: 0.12, duration: 0.12, ease: 'elastic.out(1.2, 0.5)' });

    tl.call(() => {
        startIdleAnimation();
        onComplete && onComplete();
    });
}

function animateChickenFail(failType, laneIndex) {
    gsap.killTweensOf(chickenContainer);
    gsap.killTweensOf(chickenSprites.wing);
    setChickenFace('scared-1.png');

    if (failType === 'car') {
        // Vehicle hits chicken
        const carSounds = ['trafficCarLoud1','trafficCarLoud2','trafficCarLoud3','trafficCarLoud4'];
        playSound(carSounds[Math.floor(Math.random() * carSounds.length)]);

        // Create a vehicle sprite
        const carTex = getTexture('cars', 'car-a.png');
        if (carTex !== PIXI.Texture.WHITE) {
            const car = new PIXI.Sprite(carTex);
            car.anchor.set(0.5);
            car.scale.set(0.12);
            car.zIndex = 15;
            
            const lane = laneContainers[Math.min(laneIndex, laneContainers.length - 1)];
            if (lane) {
                car.x = lane.x - 200;
                car.y = lane.y + 25;
                sceneContent.addChild(car);

                gsap.to(car, {
                    pixi: { x: lane.x + 300 },
                    duration: 0.5,
                    ease: 'power1.in',
                    onComplete: () => { car.destroy(); }
                });
            }
        }

        // Chicken gets hit
        setTimeout(() => {
            setChickenFace('dead.png');
            playSound(Math.random() > 0.5 ? 'carHit1' : 'carHit2');
            
            gsap.to(chickenContainer, {
                pixi: { y: chickenContainer.y - 50, alpha: 0, rotation: 720 },
                duration: 0.6,
                ease: 'power2.out'
            });
        }, 200);

    } else {
        // Sewer/manhole death
        playSound('grateOpening');
        setTimeout(() => {
            setChickenFace('scared-2.png');
            playSound('chickenLose');
            gsap.to(chickenContainer, {
                pixi: { scaleX: 0.06, y: chickenContainer.y + 60, alpha: 0 },
                duration: 0.5,
                ease: 'power2.in'
            });
        }, 200);
    }
}

function animateChickenWin() {
    gsap.killTweensOf(chickenContainer);
    setChickenFace('happy-1.png');
    playSound('chickenWin');

    // Victory dance
    const tl = gsap.timeline();
    tl.to(chickenContainer, { pixi: { y: chickenContainer.y - 30 }, duration: 0.2, ease: 'power2.out' });
    tl.to(chickenContainer, { pixi: { y: chickenContainer.y }, duration: 0.2, ease: 'bounce.out' });
    tl.to(chickenContainer, { pixi: { rotation: -10 }, duration: 0.15, ease: 'power1.out' });
    tl.to(chickenContainer, { pixi: { rotation: 10 }, duration: 0.15, ease: 'power1.out' });
    tl.to(chickenContainer, { pixi: { rotation: 0 }, duration: 0.15, ease: 'power1.out' });
    
    setTimeout(() => setChickenFace('laugh-1.png'), 600);
}

function resetChicken() {
    if (!chickenContainer) return;
    gsap.killTweensOf(chickenContainer);
    if (chickenSprites.wing) gsap.killTweensOf(chickenSprites.wing);
    
    chickenContainer.alpha = 1;
    chickenContainer.scale.set(0.12);
    chickenContainer.rotation = 0;
    setChickenFace('default.png');
    
    // Move to start
    if (laneContainers[0]) {
        chickenContainer.x = laneContainers[0].x + 80;
        chickenContainer.y = laneContainers[0].y + 5;
    }
    
    startIdleAnimation();
}

// ===== LANE CLICK HANDLING (HTML overlay) =====
function buildLaneOverlay() {
    // Remove existing
    const existing = document.querySelector('.lanes-overlay');
    if (existing) existing.remove();

    const overlay = document.createElement('div');
    overlay.className = 'lanes-overlay';
    overlay.id = 'lanes-overlay';

    const diff = DIFFICULTIES[currentRisk];
    const numLanes = Math.min(diff.maxRounds, 10);

    // Build from top (highest lane) to bottom (lane 0)
    for (let i = numLanes - 1; i >= 0; i--) {
        const row = document.createElement('div');
        row.className = 'lane-row';
        row.dataset.lane = i;

        // 5 tiles per lane (the standard Rainbet layout)
        for (let t = 0; t < 5; t++) {
            const tile = document.createElement('button');
            tile.className = 'lane-tile';
            tile.dataset.lane = i;
            tile.dataset.tile = t;
            tile.textContent = '?';
            tile.addEventListener('click', () => handleLaneClick(i, t));
            row.appendChild(tile);
        }

        overlay.appendChild(row);
    }

    canvasBox.appendChild(overlay);
}

function updateLaneOverlay() {
    const overlay = document.getElementById('lanes-overlay');
    if (!overlay) return;

    const tiles = overlay.querySelectorAll('.lane-tile');
    tiles.forEach(tile => {
        const laneIdx = parseInt(tile.dataset.lane);
        const tileIdx = parseInt(tile.dataset.tile);

        tile.className = 'lane-tile';
        tile.textContent = '?';

        if (state === 'playing' && laneIdx === currentRound) {
            tile.classList.add('active');
            tile.textContent = '?';
        } else if (laneIdx < currentRound && roundResults[laneIdx]) {
            const result = roundResults[laneIdx];
            if (result.chosenTile === tileIdx) {
                if (result.win) {
                    tile.classList.add('safe');
                    tile.textContent = 'üêî';
                } else {
                    tile.classList.add('fail');
                    tile.textContent = 'üíÄ';
                }
            } else {
                tile.classList.add('revealed');
                // Show where the danger was (if this lane was lost, show dangers on other tiles too)
                if (!result.win && result.dangerTiles && result.dangerTiles.includes(tileIdx)) {
                    tile.textContent = 'üöó';
                } else {
                    tile.textContent = '‚úì';
                }
            }
        } else if (state === 'game_over' && laneIdx >= currentRound) {
            tile.classList.add('revealed');
            tile.textContent = '';
        }
    });
}

// ===== GAME LOGIC =====
async function startGame() {
    betAmount = parseFloat(betInput.value) || 0;
    if (betAmount <= 0) { betInput.focus(); return; }
    if (betAmount > balance) { betAmount = balance; betInput.value = betAmount.toFixed(2); }
    if (betAmount <= 0) return;

    // Deduct bet
    balance -= betAmount;
    saveBalance();
    updateBalanceUI();

    // Setup game
    state = 'playing';
    currentRound = 0;
    roundResults = [];
    serverSeed = generateSeed();
    clientSeed = generateSeed();
    nonce = Math.floor(Math.random() * 1000000);

    playSound('chirp1');

    // Reset visuals
    sceneContent.y = 0;
    resetChicken();
    rebuildLanes();
    buildLaneOverlay();
    updateLaneOverlay();
    updateActionButton();
    updatePayout();
    updateMultTrail();
    layoutScene();

    // Disable inputs
    betInput.disabled = true;
    document.querySelectorAll('.risk-btn').forEach(b => b.style.pointerEvents = 'none');
    document.querySelectorAll('.bet-adj').forEach(b => b.style.pointerEvents = 'none');
}

async function handleLaneClick(laneIdx, tileIdx) {
    if (state !== 'playing' || laneIdx !== currentRound) return;

    // Determine outcome using provably fair engine
    const outcome = await determineOutcome(serverSeed, clientSeed, nonce, currentRound + 1, currentRisk);
    
    // Determine danger tile positions (based on difficulty)
    const diff = DIFFICULTIES[currentRisk];
    const numDangers = diff.factor; // Easy=1, Medium=3, Hard=5, Expert=10 ‚Äî but max 4 per lane (5 tiles)
    const actualDangers = Math.min(numDangers, 4); // Can't have more than 4 dangers in 5 tiles
    
    // Generate danger positions (excluding the chosen tile if win)
    let dangerTiles = [];
    if (outcome.win) {
        // Player wins - chosen tile is safe, place dangers randomly among others
        let others = [0,1,2,3,4].filter(t => t !== tileIdx);
        for (let d = 0; d < Math.min(actualDangers, others.length); d++) {
            const idx = Math.floor(Math.random() * others.length);
            dangerTiles.push(others.splice(idx, 1)[0]);
        }
    } else {
        // Player loses - chosen tile IS a danger
        dangerTiles.push(tileIdx);
        let others = [0,1,2,3,4].filter(t => t !== tileIdx);
        for (let d = 1; d < Math.min(actualDangers, 5); d++) {
            const idx = Math.floor(Math.random() * others.length);
            dangerTiles.push(others.splice(idx, 1)[0]);
        }
    }

    const result = {
        win: outcome.win,
        multiplier: outcome.multiplier,
        chosenTile: tileIdx,
        dangerTiles: dangerTiles
    };
    roundResults.push(result);

    if (outcome.win) {
        // Safe crossing
        currentRound++;
        playSound('chirp1');
        setChickenFace('happy-1.png');

        // Animate chicken jump
        const targetLane = laneContainers[Math.min(currentRound, laneContainers.length - 1)];
        animateChickenJump(targetLane, () => {
            setChickenFace('default.png');
            updateLaneOverlay();
            updateLaneVisuals();
            layoutScene();
        });

        updatePayout();
        updateActionButton();
        updateMultTrail();
        updateLaneOverlay();
        updateLaneVisuals();

        // Check if max rounds reached
        const maxR = DIFFICULTIES[currentRisk].maxRounds;
        if (currentRound >= maxR || currentRound >= 10) {
            // Auto cashout at max
            setTimeout(() => cashOut(), 500);
        }
    } else {
        // FAIL
        state = 'game_over';
        const failType = Math.random() > 0.5 ? 'car' : 'sewer';
        animateChickenFail(failType, currentRound);
        updateLaneOverlay();
        updateLaneVisuals();

        setTimeout(() => {
            showResult(false, betAmount, 0);
            addHistory(false, betAmount, 0, 0);
            updateActionButton();
            updatePayout();
            enableInputs();
        }, 800);
    }
}

function cashOut() {
    if (state !== 'playing' || currentRound === 0) return;

    state = 'cashing_out';
    const diff = DIFFICULTIES[currentRisk];
    const mult = diff.multipliers[currentRound - 1];
    const winAmount = betAmount * mult;

    balance += winAmount;
    saveBalance();
    updateBalanceUI();

    animateChickenWin();

    setTimeout(() => {
        state = 'game_over';
        showResult(true, winAmount, mult);
        addHistory(true, betAmount, winAmount, mult);
        updateActionButton();
        updatePayout();
        enableInputs();
    }, 600);
}

// ===== UI UPDATES =====
function updateActionButton() {
    if (state === 'idle' || state === 'game_over') {
        actBtn.className = 'act-btn cross';
        actText.textContent = 'Cross';
        actBtn.disabled = false;
    } else if (state === 'playing' && currentRound > 0) {
        const diff = DIFFICULTIES[currentRisk];
        const mult = diff.multipliers[currentRound - 1];
        const payout = betAmount * mult;
        actBtn.className = 'act-btn cashout';
        actText.textContent = 'Cashout $' + fmtMoney(payout);
        actBtn.disabled = false;
    } else {
        actBtn.className = 'act-btn cross';
        actText.textContent = 'Pick a lane ‚òùÔ∏è';
        actBtn.disabled = true;
    }
}

function updatePayout() {
    if (state === 'playing' && currentRound > 0) {
        const diff = DIFFICULTIES[currentRisk];
        const mult = diff.multipliers[currentRound - 1];
        const payout = betAmount * mult;
        payVal.textContent = '$' + fmtMoney(payout);
        payMult.textContent = (mult >= 1000 ? mult.toFixed(0) : mult.toFixed(2)) + '√ó';
        payVal.style.color = '#7DD934';
    } else {
        payVal.textContent = '$0.00';
        payMult.textContent = '0.00√ó';
        payVal.style.color = '#8B8DB5';
    }
}

function updateMultTrail() {
    multTrail.innerHTML = '';
    const diff = DIFFICULTIES[currentRisk];
    const show = Math.min(8, diff.maxRounds, 10);
    let start = 0;
    if (state === 'playing' && currentRound > 3) start = currentRound - 3;
    const end = Math.min(start + show, diff.multipliers.length);

    for (let i = start; i < end; i++) {
        const badge = document.createElement('span');
        badge.className = 'mbadge';
        const val = diff.multipliers[i];
        badge.textContent = (val >= 1000 ? val.toFixed(0) : val.toFixed(2)) + '√ó';
        if (state === 'playing' && i === currentRound) badge.classList.add('cur');
        else if (i < currentRound) badge.classList.add('done');
        multTrail.appendChild(badge);
    }
}

function showResult(won, amount, mult) {
    resultOv.className = 'result ' + (won ? 'win' : 'lose') + ' show';
    if (won) {
        resultOv.innerHTML = `<div class="result-card">
            <div class="res-emoji">üéâ</div>
            <div class="res-text">You Won!</div>
            <div class="res-amount">+$${fmtMoney(amount)}</div>
            <div class="res-mult">${mult >= 1000 ? mult.toFixed(0) : mult.toFixed(2)}√ó multiplier</div>
            <div class="res-dismiss">Click to dismiss</div>
        </div>`;
    } else {
        resultOv.innerHTML = `<div class="result-card">
            <div class="res-emoji">üíÄ</div>
            <div class="res-text">Busted!</div>
            <div class="res-amount">-$${fmtMoney(amount)}</div>
            <div class="res-mult">Better luck next time</div>
            <div class="res-dismiss">Click to dismiss</div>
        </div>`;
    }
    clearTimeout(window._rt);
    window._rt = setTimeout(() => { resultOv.classList.remove('show'); }, 3500);
}

function addHistory(won, bet, winAmount, mult) {
    const item = document.createElement('div');
    item.className = 'hist-item ' + (won ? 'win' : 'lose');
    item.innerHTML = won
        ? `<span>üêî ${mult >= 1000 ? mult.toFixed(0) : mult.toFixed(2)}√ó</span><span>+$${fmtMoney(winAmount)}</span>`
        : `<span>üíÄ Busted</span><span>-$${fmtMoney(bet)}</span>`;
    histList.insertBefore(item, histList.firstChild);
    while (histList.children.length > 10) histList.removeChild(histList.lastChild);
}

function enableInputs() {
    state = 'idle';
    betInput.disabled = false;
    document.querySelectorAll('.risk-btn').forEach(b => b.style.pointerEvents = 'auto');
    document.querySelectorAll('.bet-adj').forEach(b => b.style.pointerEvents = 'auto');
}

// ===== EVENT LISTENERS =====
actBtn.addEventListener('click', () => {
    if (state === 'idle' || state === 'game_over') startGame();
    else if (state === 'playing' && currentRound > 0) cashOut();
});

document.querySelectorAll('.risk-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        if (state === 'playing') return;
        document.querySelectorAll('.risk-btn').forEach(b => b.classList.remove('on'));
        btn.classList.add('on');
        currentRisk = btn.dataset.risk;
        rebuildLanes();
        updateMultTrail();
        layoutScene();
        buildLaneOverlay();
    });
});

document.getElementById('btn-half').addEventListener('click', () => {
    if (state === 'playing') return;
    betInput.value = Math.max(0.01, (parseFloat(betInput.value) || 0) / 2).toFixed(2);
});

document.getElementById('btn-2x').addEventListener('click', () => {
    if (state === 'playing') return;
    betInput.value = Math.min(balance, (parseFloat(betInput.value) || 0) * 2).toFixed(2);
});

function resetBalance() {
    if (state === 'playing') return;
    if (confirm('Reset balance to $1,247.83?')) {
        balance = 1247.83;
        saveBalance();
        updateBalanceUI();
    }
}
document.getElementById('hdr-bal').addEventListener('click', resetBalance);
document.getElementById('reset-btn').addEventListener('click', resetBalance);

resultOv.addEventListener('click', () => { resultOv.classList.remove('show'); });

// Keyboard
document.addEventListener('keydown', e => {
    if (document.activeElement === betInput && e.key !== 'Enter') return;

    if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        if (state === 'idle' || state === 'game_over') startGame();
        else if (state === 'playing' && currentRound > 0) cashOut();
    }

    if (state === 'playing' && currentRound < DIFFICULTIES[currentRisk].maxRounds) {
        const num = parseInt(e.key);
        if (num >= 1 && num <= 5) {
            e.preventDefault();
            handleLaneClick(currentRound, num - 1);
        }
    }

    if (e.key === 'Escape') {
        e.preventDefault();
        if (state === 'playing' && currentRound > 0) cashOut();
        else resultOv.classList.remove('show');
    }
});

// ===== INIT =====
updateBalanceUI();
updatePayout();
updateActionButton();
updateMultTrail();
loadSounds();

// Init PixiJS after DOM ready
requestAnimationFrame(() => {
    initPixi().then(() => {
        buildLaneOverlay();
        console.log('üêî Chicken Cross loaded!');
    }).catch(err => {
        console.error('PixiJS init failed:', err);
        // Fallback - game still works with HTML overlay
        buildLaneOverlay();
    });
});

// Service worker
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/service-worker.js').catch(() => {});
}

})();
</script>
</body>
</html>
